#include<set>

1.使用set容器存储的各个键值对，要求键key和值value必须相等。
2.set容器也会根据键的大小对存储的键值进行排序。
3.在正常情况下，用户是无法做到修改set容器中元素的值。  正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。（请勿直接修改set中元素的值）
4.默认会对set容器类进行升序排序。

	和 map 容器不同，C++ STL 中的 set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。   重要！！！
	因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。但是迭代器类型为双向迭代器。

注意，以上成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。
另外，以上成员方法返回的迭代器，无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值。

了解一下：为什么已经默认是排序的，还按照迭代器进行插入。有什么必要？

和 set 容器不同的是，multiset 容器可以存储多个值相同的元素。



无序关联式容器
#include<map>

底层结构式哈希表的存储结构，解决方法是“链地址法”

和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；
但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。

